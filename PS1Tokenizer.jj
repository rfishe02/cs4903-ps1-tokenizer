/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  static = false;
  LOOKAHEAD=1;
}

PARSER_BEGIN(UATokenizer)

import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.File;
import java.io.InputStreamReader;

public class UATokenizer {
    
  static boolean test = false;
  
  public static void main(String args[]) throws ParseException {
    if(test) {
      args = new String[2];
      args[0] = "./input/test.txt";
      args[1] = "./output";
    }
    run(args);
  }

  public static void run(String[] args) {
    BufferedWriter bw2;
    File[] files;
    File[] zDir;
    File inDir;
    String[] spl;
    String filename;
    int[] count = new int[7];
    long start;

    try {
      inDir = new File(args[0]);
      files = inDir.listFiles();
      
      File outDir = new File(args[1]);
      
      if(!outDir.exists()) {
        outDir.mkdir();
      }
      
      BufferedWriter[] bw = getWriters(outDir);
      start = System.currentTimeMillis();
      
      if(files == null) {
        bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+inDir.getName()+".out"));
        processFile(bw,bw2,inDir,count); // Process a single file.
        bw2.close();
      } else {
      
        for(File f : files) {
            
            zDir = f.listFiles();
            
            if(zDir != null) {
                
                for(File z : zDir) {
                    bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+z.getName()+".out"));
                    processFile(bw,bw2,z,count); // Process a files in a subdirectory.
                    bw2.close();
                }
	    
            } else {
                bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+f.getName()+".out"));
                processFile(bw,bw2,f,count); // Process multiple files.
                bw2.close();
            }
        }
      }
      closeWriters(bw);
      printResults(count,start);
		
    } catch(IOException ex) {
      ex.printStackTrace();
      System.exit(1);
    }
  }
  
    public static BufferedWriter[] getWriters(File inDir) {
    BufferedWriter[] bw = null;
    
    try {
      String[] filenames = {"other.txt","email.txt","domain.txt","price.txt","word.txt","phone.txt"};
      bw = new BufferedWriter[filenames.length];
      
      for (int i = 0; i < filenames.length; i++) {
        bw[i] = new BufferedWriter(new FileWriter(inDir.getPath()+"/"+filenames[i]));
      }
      
    } catch(IOException ex) {
      ex.printStackTrace();
      System.exit(1);
    }
    return bw;
  }

  public static void closeWriters(BufferedWriter[] bw) {
    try {
      for(BufferedWriter b : bw) {
        b.close();
      }
    } catch(IOException ex) {
      System.exit(1);
    }
  }

  public static void processFile(BufferedWriter[] bw, BufferedWriter bw2, File f, int[] count) throws IOException {
    BufferedReader bis;
    UATokenizer parser;
    Token t;
    
    bis = new BufferedReader(new InputStreamReader(new FileInputStream(f),"UTF-8"));
    parser = new UATokenizer(bis);
    
    do {
      t = parser.getNextToken();
      
      bw2.write(t.image.toLowerCase()+"\n");
      recordToken(bw,t,count);
      
    } while(t.kind != UATokenizerConstants.EOF);
    
      bis.close();
      count[1]++;
  }
  
  public static void recordToken(BufferedWriter[] bw, Token t, int[] count) {
    try {
      String type = UATokenizer.tokenImage[t.kind];
      String fmt = t.image.toLowerCase();
      //String fmt = t.image.toLowerCase()+" "+type;
      
      count[0]++; // Count number of tokens processed.
      
      if(fmt.length() > 1) {
        if(type.equals("<EMAIL>")||type.equals("<EMAIL2>")) {
            bw[1].write(fmt+"\n");
            count[2]++;
		
        } else if(type.equals("<HTTPDOM>")||type.equals("<HTTPDOM2>")) {
            bw[2].write(fmt+"\n");
            count[3]++;

        } else if(type.equals("<PRICE>")) {
            bw[3].write(fmt+"\n");
            count[4]++;
		
        } else if(type.equals("<PHONE34>")|| type.equals("<PHONE32>")|| type.equals("<PHONE58>")) {
            bw[5].write(fmt+"\n");
            count[6]++;
		
        } else if(type.equals("<ALTWORD>")|| type.equals("<WORD>")|| type.equals("<CROWDED>")|| type.equals("<CROWDED2>")|| type.equals("<BREV>") || type.equals("<DOCSQWRD>") || type.equals("<DOCDQWRD>")) {
            bw[4].write(fmt+"\n");
            count[5]++;
        } else {
            bw[0].write(fmt+"\n"); // Write remaining tokens to a separate file.
        }
      } 

    } catch(IOException ex) {
      System.exit(1);
    }
  }

  public static void printResults(int[] count, long start) {
    try {
      BufferedWriter bw = new BufferedWriter(new FileWriter("summary.txt"));
      String[] label = {"Total tokens: ","Files processed: ","Emails found: ","Domains found: ","Prices found: ","Words found: ","Phone #s found:"};
      
      bw.write("======= Project Gengar Tokenization Summary =======\n");
      for(int i = 0; i < label.length; i++) {
        bw.write(String.format("%-25s %-50d\n",label[i],count[i]));
      }
      bw.write(String.format("%-25s %-50.2f\n","Total runtime (seconds): ",(System.currentTimeMillis()-start)/1000.0));
      bw.close();
    } catch(IOException ex) {
      System.exit(1);
    }
  }
}

PARSER_END(UATokenizer)

TOKEN_MGR_DECLS : {

  String[] tmp;
  String cSep = "('|’|-|\u2019|&#39;|&#44;|&#x27;|&#45;)";
  String pSep = "([\\(]|[\\)]|[+]|&#43;|&#45;|&#46;)";
  String sSep = "(&#39;|&#039;|&#39;s|&#039;s|&#x27;|&#183;|&#034;|&#821)";
  String pReg = "[\\s,\\.,-]";
  String p = "-";
  String w = ".";
  int wordEnd;
  int tagSt;
  boolean tagCt;
  boolean cont;

}

/* ============================================================================================
 
   DEFINE SYMBOLS THAT MAY BE SKIPPED OR USED LATER.
 
 ============================================================================================ */

SKIP : {
  < SPACE : (" "|"\t"|"&#160;")+ >
| < NEWLINE : ("\r"|"\n")+ >
| < CSEP : ("'"|"’"|"\u2019"|"â€™"|"&#x27;"|"&#" (["3"-"4"]){2}  ";") >
| < PSEP : (["-"," ","."]|"&#8722;"|"&#46;") > // Phone seperator. 
}

SKIP : {
  < ENGSYMB : "&" ( "#" (["0"-"9"]){1} ( (["0"-"9"]){1} | ((["0"-"5"]){1}|(["7"-"9"]){1}) (["0"-"9"]){1} )
    | (["a","A","e","E","i","I","o","O","u","U","n","N"]|"sz"|"ord") 
      ("acute"|"cedil"|"circ"|"grave"|"lig"|"slash"|"tilde"|"uml"|"ring"|["f","m"]) 
    | ("middot"|"eth"|"ETH"|"thorn"|"THORN") ) ";" >
| < SYMBOL : "&" ("#")?(["a"-"z","0"-"9"]){2,12} ";" >
}

/* ============================================================================================
 
   SKIP TAGS, OR PORTIONS OF TAGS THAT MAY NOT CONTAIN USEFUL INFORMATION.
 
 ============================================================================================ */

SKIP : {
  < SCRIPTTAG :  "<" (" ")*"script"(" ")* > : IN_SCRIPT_TAG
| < SPTAG : "<" (" ")*("style"|"button"|"noscript"|"time")(" ")* > : IN_SP_TAG
| < SELFCLOSETAG : "<" (" ")*("!"|"meta"|"td"|"table"|"path")(" ")* > : IN_SELFCLOSE_TAG
| < PHP : "<" (" ")*"?php"(" ")* > : IN_PHP
| < OPENTAG : "<" (" ")*(["a"-"z","A"-"Z","0"-"9","-"])+(" ")* >
| < CLOSETAG : "<" (" ")* ( "/"(" ")*(["a"-"z","A"-"Z","0"-"9","-"])+ 
               | (["a"-"z","A"-"Z","0"-"9","-"])+ (" ")*"/" ) (" ")* >
}

/* --------------------------------------------------------------------------------------------
 
   When we enter a script tag, only save the words that lie between document.write( ) code.
 
 -------------------------------------------------------------------------------------------- */

< IN_SCRIPT_TAG > SKIP : {
  < ENDSCRIPTTAG : "<" (" ")*"/"(" ")* "script" > : DEFAULT
| < DOCWRITE : "document.write" (" ")* ["("] > : IN_DOC
| < SCRIPTTAGMISC : ~[] > 
}
<IN_DOC> SKIP : {
  < ENDDOC : ");" > : IN_SCRIPT_TAG 
| < STDOCSQ : ["'"] > : IN_DOC_SQ
| < SQDOCDQ : ["\""] > : IN_DOC_DQ
| < DOCMISC : ~[] > 
}

// Deal with tags that used single quotes.

<IN_DOC_SQ> TOKEN : {
    < DOCSQWRD : < WORD > >
}
<IN_DOC_SQ> SKIP : {
  < ENDDOCSQ : ["'"] > : IN_DOC
| < DOCSQOT : ["<"] > : DOC_SQ_TAG
| < DOCSQCT : < CLOSETAG > >
| < DOCSQMISC : ~[] > 
}
<DOC_SQ_TAG> SKIP : {
  < ENDDOCSQTAG : [">"] > : IN_DOC_SQ
| < DOCSQTGMISC : ~[] > 
}

// Deal with tags that used double quotes.

<IN_DOC_DQ> TOKEN : {
    < DOCDQWRD : < WORD > >
}
<IN_DOC_DQ> SKIP : {
  < ENDDOCDQ : ["\""] > : IN_DOC
| < DOCDQOT : ["<"] > : DOC_DQ_TAG
| < DOCDQCT : < CLOSETAG > >
| < DOCDQMISC : ~[] > 
}
<DOC_DQ_TAG> SKIP : {
  < ENDDOCDQTAG : [">"] > : IN_DOC_DQ
| < DOCDQTGMISC : ~[] > 
}

/* --------------------------------------------------------------------------------------------
 
   These are specific tags that we'll skip completely.
 
 -------------------------------------------------------------------------------------------- */

< IN_SP_TAG > SKIP : {
  < ENDATAG : "<" (" ")*"/"(" ")* "style" > : DEFAULT
| < ENDCTAG : "<" (" ")*"/"(" ")* "button" > : DEFAULT
| < ENDDTAG : "<" (" ")*"/"(" ")* "noscript" > : DEFAULT
| < ENDETAG : "<" (" ")*"/"(" ")* "time" > : DEFAULT
| < SPTAGMISC : ~[] >
}
< IN_PHP > SKIP : {
  < ENDPHP : "?>" > : DEFAULT
| < PHPMISC : ~[] >
}
< IN_SELFCLOSE_TAG > SKIP : {
  < ENDOPTAG : (">") > : DEFAULT
| < SELFCLOSEMISC : ~[] >
}

/* Skip code between PRE and CODE tags. The biggest issue with these tags is that 
 * they may contain distinct terms.
 */

SKIP : {
  < PRETAG :  "<" (" ")*("pre"|"code")(" ")* > : IN_PRE_TAG
}
< IN_PRE_TAG > SKIP : {
  < ENDPRETAG : "<" (" ")*"/"(" ")* "pre" > : DEFAULT
| < ENDCODETAG : "<" (" ")*"/"(" ")* "code" > : DEFAULT
| < PREMISC : ~[] >
}

/* ============================================================================================
 
   Skip the contents of HTML attributes that may contain unhelpful information, such 
   as style definitions.
 
 ============================================================================================ */

SKIP : {
  < ALTATTR : ("alt"|"title") (" ")*"="(" ")* ("\""|"'") > : IN_ALT
| < HREFATTR :  "href" (" ")*"="(" ")* ("\""|"'") > : IN_HREF_LNK
}

// The alt tag may contain useful descriptive information.

<IN_ALT> SKIP : {
  < ENDALT : ("'"|"\"") > : DEFAULT
| < ALTMISC: ~[] >
}
<IN_ALT> TOKEN : {
  < ALTWORD : <WORD> > { }
}

// This graps links within HREF. This may create redundant links to parts within the website.

<IN_HREF_LNK> SKIP : {
  < HTTPJNK2 : <HTTPJNK> >
| < HTTPLNK2 : <HTTPLNK> >
| < HTTP2 : <HTTP> >
| < PORT2 : <PORT> >
| < ENDHTMLATTR : ("'"|"\"") > : DEFAULT
| < SPATTRMISC: ~[] >
}
<IN_HREF_LNK> TOKEN : {
  < HTTPDOM2 : ( (["a"-"z","A"-"Z","0"-"9","-"]){1}(["a"-"z","A"-"Z","0"-"9","-"])+(".") )+ (["a"-"z","A"-"Z","0"-"9","-"])+ > {
    /*tmp = image.toString().split("\\.");
    if(tmp.length > 2) {
      matchedToken.image = tmp[tmp.length-3]+"."+tmp[tmp.length-2]+"."+tmp[tmp.length-1];
    } else {
      matchedToken.image = tmp[tmp.length-2]+"."+tmp[tmp.length-1];
    }*/
  }
| < EMAIL2 : <EMAIL> >
}

// If we're in a basic tag, use a double quote or single quote depending on the syntax.

SKIP : {
  < HTMLATTRSQ : (["a"-"z","A"-"Z","-","_",":"])+ (" ")*"="(" ")* "'" > : IN_HTMLATTR_SQ
| < HTMLATTRDQ : (["a"-"z","A"-"Z","-","_",":"])+ (" ")*"="(" ")* "\"" > : IN_HTMLATTR_DQ
}
< IN_HTMLATTR_SQ > SKIP : {
  < ENDSPATTR2 : "'" > : DEFAULT
| < HTMLATTRMISC2 : ~[] >
}
< IN_HTMLATTR_DQ > SKIP : {
  < ENDSPATTR : "\"" > : DEFAULT
| < HTMLATTRMISC1 : ~[] >
}

/* ============================================================================================
 
   DEFINITIONS OF CONSTRUCTIONS LIKE TIME, DATES, PRICES, AND PHONE NUMBERS
 
 ============================================================================================ */

SKIP : {
  < TIME : ( (["0"-"9"]){1,2} (":") ( (["0"-"9"]){2} (":"|"&#58;")? )+ (" ")? (["a"-"z","A"-"Z"]){0,2}
           | (["0"-"9"]){2}":"(["0"-"9"]){2}" "( ["A"-"Z"]){2} ( " "(["A"-"Z"]){2} )? ) >
| < DATE : ( (["0"-"9"]){2}< PSEP >(["0"-"9"]){2}< PSEP >(["0"-"9"]){2,4}  
           | (["0"-"9"]){2}< PSEP >(["A"-"Z"]){3,4}< PSEP >(["0"-"9"]){2,4}
           | (["0"-"9"]){2,4}< PSEP>(["0"-"9"]){2}< PSEP >(["0"-"9"]){2}  
           )>
}

TOKEN : {
 < PRICE : (["$","£","¥"]|"&#36;"|"&#163;"|"&#165;")(" ")* ( (["0"-"9"]){1,3}(",")? )+ ( [".",","](["0"-"9"])+ )? > // Need to add unicode & html symb?
}

/* --------------------------------------------------------------------------------------------
 
   Uses a pattern based approach to identify phone numbers. The most popular numbers 
   internationally had groupings of 3-3-3, 3-3-4, 3-2-2, 2-2-2, or 5-8, which were 
   preceded by specific codes.
 
 -------------------------------------------------------------------------------------------- */

TOKEN : {
  < PHONEFI : ("+"|"&#43;") < PSEP > > 
| < PHONESE : ("(")?(["0"-"9"]){1,4}(")")? < PSEP > >
| < PHONE34 : ( ( ( <PHONEFI> )? <PHONESE> )? < PHONESE > )?
              (["0"-"9"]){3,4}< PSEP > (["0"-"9"]){3,4} > { 
    /*tmp = image.toString().replaceAll(pSep,"").split(pReg);
    if(tmp.length > 1) {
      matchedToken.image = tmp[tmp.length-2] +p+ tmp[tmp.length-1];
    }*/
  }
| < PHONE32 : ( ( ( <PHONEFI> )? <PHONESE> )? < PHONESE > )?
              (["0"-"9"]){2,3}< PSEP > (["0"-"9"]){2}< PSEP > (["0"-"9"]){2} > { 
    /*tmp = image.toString().replaceAll(pSep,"").split(pReg);
    if(tmp.length > 2) {
      matchedToken.image = tmp[tmp.length-3] +p+ tmp[tmp.length-2] +p+ tmp[tmp.length-1];
    }*/
  }
| < PHONE58 : ( < PHONEFI > (["0"-"9"]){1,2}< PSEP > )?
              ("(")?(["0"-"9"]){2,5}(")")?< PSEP > (["0"-"9"]){5,8} > { 
    /*tmp = image.toString().replaceAll(pSep,"").split(pReg);
    if(tmp.length > 1) {
      matchedToken.image = tmp[tmp.length-2] +p+ tmp[tmp.length-1];
    }*/
  }
}

/* ============================================================================================
 
   REGEX USED TO COLLECT WORDS.
   THE FOLLOW REGEX MAY GRAB COMBINED WORDS / TRICKY NUMBERS.
 
 ============================================================================================ */

/* The tokenizer may pass through MORE once or twice. Eventually, the segment
 * will be classified as a WORD or NUMBER.
 */

MORE : {
  < CONT : <WORD> (< CSEP >|"-") > { /*cont = true;*/ }
| < BIGNUM : (["0"-"9"])+(","|"&#44;"|"."|"&#46;") >
}

// Deals with situations where terms are too close to tags.

TOKEN : {
  < CROWDED : ">" (< CONT >)? <WORD> > {
    matchedToken.image = image.substring(image.indexOf(">")+1,image.length());
    
    //matchedToken.image = matchedToken.image.replaceAll(cSep,"");
    
  }
| < CROWDED2 : (< CONT >)? <WORD> < CLOSETAG > > {
    matchedToken.image = image.substring(0,image.indexOf("<"));
    
    //matchedToken.image = matchedToken.image.replaceAll(cSep,"");	
    
  }
}

/* --------------------------------------------------------------------------------------------
 
   The following identifies basic words / numbers.
 
 -------------------------------------------------------------------------------------------- */

TOKEN : {
  < WORD : ( ["a"-"z","A"-"Z"] ( < ENGSYMB > )? )+ > {
      if(tagCt) {
        matchedToken.image = image.toString(); // If this word had punctuation, return the modfied image.
        tagCt = false;
      }
      
      /*
      if(cont) {
        matchedToken.image = image.toString().replaceAll(cSep,"");
        cont=false;
      }*/
      
    }
| < BREV : ( ["A"-"Z","a"-"z"] ("&#46;"|["0"-"9","."]) ){1,6} ["A"-"Z","a"-"z"] > {
    matchedToken.image = matchedToken.image.replaceAll("(\\.-)","").trim();
  }
}

SKIP : {
  < NUMBER : (["0"-"9"])+>
| < MISC: ~[] >
}

/* ============================================================================================
 
   Skip parts of the url that may contribute more garbage than relevant information.
 
 ============================================================================================ */

SKIP : {
  < HTTPJNK : ("&"|"?") (["a"-"z","A"-"Z","0"-"9",".","-","_",";",":","+","^","%","="])+ >
| < HTTPLNK : "/" (["a"-"z","A"-"Z","0"-"9",".","-","_",";",":","+","^"," "])+ >
| < HTTP : (["a"-"z"])+"://" >
| < PORT : ":"(["0"-"9"]){4} >
}

/*
  Only retain HTML domains, parts of the url, email addresses that seem useful.
*/

TOKEN : {	
  < HTTPDOM : ( (["a"-"z","A"-"Z","0"-"9","-"]){1}(["a"-"z","A"-"Z","0"-"9","-"])+(".") )+ (["a"-"z","A"-"Z","0"-"9","-"])+ > {
    /*tmp = image.toString().split("\\.");
    if(tmp.length > 2) {
      matchedToken.image = tmp[tmp.length-3]+"."+tmp[tmp.length-2]+"."+tmp[tmp.length-1];
    } else {
      matchedToken.image = tmp[tmp.length-2]+"."+tmp[tmp.length-1];
    }*/
  }
| < EMAIL : (["a"-"z","A"-"Z","0"-"9","_",".","+","-","#","$","%","&","!","*","?","^","*"])+ 
            (["a"-"z","A"-"Z","0"-"9","_",".","+","-","#","$","%","&","!","*","?","^","*","="])?
            "@" ( (["a"-"z","A"-"Z"])+(".") )+ (["a"-"z","A"-"Z"])+ > {
    /*tmp = image.toString().split("\\.");
    matchedToken.image = tmp[tmp.length-1];*/
  }
}

/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  static = false;
  LOOKAHEAD=1;
}

PARSER_BEGIN(UATokenizer)

import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.File;
import java.io.InputStreamReader;

public class UATokenizer {
    
  static boolean test = false;
  
  public static void main(String args[]) throws ParseException {
    if(test) {
      args = new String[2];
      args[0] = "./input/test.txt";
      args[1] = "./output";
    }
    run(args);
  }

  public static void run(String[] args) {
    BufferedWriter bw2;
    File[] files;
    File[] zDir;
    File inDir;
    String[] spl;
    String filename;
    int[] count = new int[7];
    long start;

    try {
      inDir = new File(args[0]);
      files = inDir.listFiles();
      
      File outDir = new File(args[1]);
      
      if(!outDir.exists()) {
        outDir.mkdir();
      }
      
      BufferedWriter[] bw = getWriters(outDir);
      start = System.currentTimeMillis();
      
      if(files == null) {
        bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+inDir.getName()+".out"));
        processFile(bw,bw2,inDir,count); // Process a single file.
        bw2.close();
      } else {
      
        for(File f : files) {
            
            zDir = f.listFiles();
            
            if(zDir != null) {
                
                for(File z : zDir) {
                    bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+z.getName()+".out"));
                    processFile(bw,bw2,z,count); // Process a files in a subdirectory.
                    bw2.close();
                }
	    
            } else {
                bw2 = new BufferedWriter(new FileWriter(args[1]+"/"+f.getName()+".out"));
                processFile(bw,bw2,f,count); // Process multiple files.
                bw2.close();
            }
        }
      }
      closeWriters(bw);
      printResults(count,start);
		
    } catch(IOException ex) {
      ex.printStackTrace();
      System.exit(1);
    }
  }
  
    public static BufferedWriter[] getWriters(File inDir) {
    BufferedWriter[] bw = null;
    
    try {
      String[] filenames = {"other.txt","email.txt","domain.txt","price.txt","word.txt","phone.txt"};
      bw = new BufferedWriter[filenames.length];
      
      for (int i = 0; i < filenames.length; i++) {
        bw[i] = new BufferedWriter(new FileWriter(inDir.getPath()+"/"+filenames[i]));
      }
      
    } catch(IOException ex) {
      ex.printStackTrace();
      System.exit(1);
    }
    return bw;
  }

  public static void closeWriters(BufferedWriter[] bw) {
    try {
      for(BufferedWriter b : bw) {
        b.close();
      }
    } catch(IOException ex) {
      System.exit(1);
    }
  }

  public static void processFile(BufferedWriter[] bw, BufferedWriter bw2, File f, int[] count) throws IOException {
    BufferedReader bis;
    UATokenizer parser;
    Token t;
    
    bis = new BufferedReader(new InputStreamReader(new FileInputStream(f),"UTF-8"));
    parser = new UATokenizer(bis);
    
    do {
      t = parser.getNextToken();
      
      recordToken(bw,bw2,t,count);
      
    } while(t.kind != UATokenizerConstants.EOF);
    
      bis.close();
      count[1]++;
  }
  
  public static void recordToken(BufferedWriter[] bw, BufferedWriter bw2, Token t, int[] count) {
    try {
      String type = UATokenizer.tokenImage[t.kind];
      
      String fmt = t.image.toLowerCase();
      //String fmt = t.image.toLowerCase()+" "+type;
      
      bw2.write(fmt+"\n");
      count[0]++; // Count number of tokens processed.
      
      if(fmt.length() > 2) {
        if(type.equals("<EMAIL>")    ||type.equals("<DQEMAIL>")   ||type.equals("<SQEMAIL>")||
           type.equals("<JSEMAILSQ>")||type.equals("<JSEMAILDQ>")) {
            
            bw[1].write(fmt+"\n");
            count[2]++;

        } else if(type.equals("<HTTPDOM>")||type.equals("<SQDOM>")   ||type.equals("<DQDOM>")||
                  type.equals("<JSDOMSQ>")||type.equals("<JSDOMDQ>")) {
            
            bw[2].write(fmt+"\n");
            count[3]++;

        } else if(type.equals("<PRICE>")||type.equals("<PRICE2>")) {
            
            bw[3].write(fmt+"\n");
            count[4]++;

        } else if(type.equals("<WORD>")    ||type.equals("<CONT>")    ||type.equals("<CROWDED>")  ||
                  type.equals("<CROWDED2>")||type.equals("<BREV>")    ||type.equals("<SQWORD>")   || 
                  type.equals("<DQWORD>")  ||type.equals("<JSWORDSQ>")||type.equals("<JSWORDDQ>")) {
            
            if(fmt.length() > 8) {
                fmt = fmt.substring(0,9); // Reduce the size of the word to a length of 9.
            }
            
            bw[4].write(fmt+"\n");
            count[5]++;
            
        } else if(type.equals("<PHONE34>")  ||type.equals("<PHONE32>")   || type.equals("<PHONE58>")||
                  type.equals("<JSPHONESQ>")||type.equals("<JSPHONEDQ>")) {
            
            bw[5].write(fmt+"\n");
            count[6]++;

        }  else {
            bw[0].write(fmt+"\n"); // Write remaining tokens to a separate file.
        }
      }

    } catch(IOException ex) {
      System.exit(1);
    }
  }

  public static void printResults(int[] count, long start) {
    try {
      BufferedWriter bw = new BufferedWriter(new FileWriter("summary.txt"));
      String[] label = {"Total tokens: ","Files processed: ","Emails found: ","Domains found: ","Prices found: ","Words found: ","Phone #s found:"};
      
      bw.write("======= Project Gengar Tokenization Summary =======\n");
      for(int i = 0; i < label.length; i++) {
        bw.write(String.format("%-25s %-50d\n",label[i],count[i]));
      }
      bw.write(String.format("%-25s %-50.2f\n","Total runtime (seconds): ",(System.currentTimeMillis()-start)/1000.0));
      bw.close();
    } catch(IOException ex) {
      System.exit(1);
    }
  }

}

PARSER_END(UATokenizer)

TOKEN_MGR_DECLS : {

  String[] tmp;
  String cSep = "('|’|-|\u2019|&#39;|&#44;|&#x27;|&#45;)";
  String pSep = "([\\(]|[\\)]|[+]|&#43;|&#45;|&#46;)";
  String sSep = "(&#39;|&#039;|&#39;s|&#039;s|&#x27;|&#183;|&#034;|&#821)";
  String pReg = "[\\s,\\.,-]";
  String p = "";
  String w = ".";
  int wordEnd;
  int tagSt;
  boolean tagCt;
  boolean cont;
  
  public String cleanPhone(String str) {
    
    String tmp = str;
    String[] spl = tmp.replaceAll(pSep,"").split(pReg);
    
    if(spl.length > 2) {
      tmp = spl[spl.length-3] +p+ spl[spl.length-2] +p+ spl[spl.length-1];
    } else if(spl.length > 1) {
      tmp = spl[spl.length-2] +p+ spl[spl.length-1];
    }
    
    return tmp;
      
  }
  
  public String cleanWord(String str) {
   
    return str.replaceAll(cSep,"");
      
  }
  
  public String cleanHTML(String str) {
   
      String tmp = str;
      String[] spl = str.split("\\.");
      
      if(spl.length > 2) {
          tmp = spl[spl.length-3]+w+spl[spl.length-2]+w+spl[spl.length-1];
      } else {
          tmp = spl[spl.length-2]+w+spl[spl.length-1];
      }
 
      return tmp;
      
  }

}

/* ============================================================================================
 
   DEFINE SYMBOLS THAT MAY BE SKIPPED OR USED LATER.
 
 ============================================================================================ */

SKIP : {
  < SPACE : (" "|"\t"|"&#160;")+ >
| < NEWLINE : ("\r"|"\n")+ >
| < CSEP : ("'"|"’"|"\u2019"|"â€™"|"&#x27;"|"&#" (["3"-"4"]){2} ";") > // Contraction seperator.
| < PSEP : (["-"," ","."]|"&#8722;"|"&#46;") > // Phone seperator. 
| < HTTPSYM : [",","-","_",":","+","^","%","#","=","@","~","[","]","$","(",")","*"] >
| < LINKSYM : [",","-","_",":","+","^","%","#","=","@","~","[","]","$","(",")","*"," "]>
| < EMAILSYM : ["!","#","$","%","^","&","*","_","+","=","-"] >
}

SKIP : {
  < ENGSYMB : "&" ( "#" (["0"-"9"]){1} ( (["0"-"9"]){1} | ((["0"-"5"]){1}|(["7"-"9"]){1}) (["0"-"9"]){1} )
    | (["a","A","e","E","i","I","o","O","u","U","n","N"]|"sz"|"ord") 
      ("acute"|"cedil"|"circ"|"grave"|"lig"|"slash"|"tilde"|"uml"|"ring"|["f","m"]) 
    | ("middot"|"eth"|"ETH"|"thorn"|"THORN") ) ";" >
| < SYMBOL : "&" ("#")?(["a"-"z","0"-"9"]){2,12} ";" >
| < ALPHA : (["a"-"z","A"-"Z"] | ("\\u00"["4"-"7"]["0"-"9","A"-"F"]) | ("\\u00"["A"-"F"]["0"-"9","A"-"F"]) ) >
}

/* ============================================================================================
 
   SKIP TAGS, OR PORTIONS OF TAGS THAT MAY NOT CONTAIN USEFUL INFORMATION.
 
 ============================================================================================ */

// Tags we'll enter and either tokenize, or skip altogther.

// type="application/json+oembed"
//< SCRIPTTAG :  "<" (" ")*("script"|"SCRIPT")(" ")* "type="(" ")*["\"","'"](" ")* ((["a"-"z","/","+"])+)?("json"|"javascript")((["a"-"z","/","+"])+)? (" ")*["\"","'"] > : IN_JS 

SKIP : {
  < SCRIPTTAG2 :  "<" (" ")*("script"|"SCRIPT")(" ")* > : IN_SCRIPT 
| < SPTAG : "<" (" ")*("style"|"STYLE"|"button"|"BUTTON"|"noscript"|"NOSCRIPT"|"time"|"TIME")(" ")* > : IN_SP_TAG
| < PRETAG :  "<" (" ")*("pre"|"PRE"|"code"|"CODE")(" ")* > : IN_CODE_TAG
| < PHP : "<" (" ")*"?php"(" ")* > : IN_PHP
}

< IN_SP_TAG > SKIP : {
  < ENDATAG : "<" (" ")*"/"(" ")* ("style"|"STYLE"|"button"|"BUTTON"|"noscript"|"NOSCRIPT"|"time"|"TIME") > : DEFAULT
| < SPCMT : "/*" > : SP_CMT
| < SPTAGMISC : ~[] >
}
< SP_CMT > SKIP : {
  < ENDSPCMT : "*/" > : IN_SP_TAG
| < SPCMTMISC : ~[] >
}

< IN_CODE_TAG > SKIP : {
  < ENDPRETAG : "<" (" ")*"/"(" ")* ("pre"|"PRE"|"code"|"CODE") > : DEFAULT
| < PREMISC : ~[] >
}

< IN_PHP > SKIP : {
  < ENDPHP : "?"(" ")*">" > : DEFAULT
| < PHPCMT : "/*" > : PHP_CMT
| < PHPMISC : ~[] >
}
< PHP_CMT > SKIP : {
  < ENDPHPCMT : "*/" > : IN_PHP
| < PHPCMTMISC : ~[] >
}

/* --------------------------------------------------------------------------------------------
 
   When we enter a script tag, use different tokenization techniques depending on the type.
 
 -------------------------------------------------------------------------------------------- */

< IN_SCRIPT > SKIP : {
  < ENDJS : "<" (" ")*"/"(" ")* ("script"|"SCRIPT") > : DEFAULT
| < DOCWRITE : "document.write"(" ")*"(" > :IN_DOC_WRITE
| < SCRIPTCMT : "/*" > : IN_SC_CMT
| < JSSQ : ("description"|"email"|"url"|"href"|("tele")?"phone"|"alt") (" ")*"'"(" ")*":"(" ")*"'" > : IN_JSSQ
| < JSDQ : ("description"|"email"|"url"|"href"|("tele")?"phone"|"alt") (" ")*"\""(" ")*":"(" ")*"\"" > : IN_JSDQ
| < SCRIPTTAGMISC : ~[] > 
}
< IN_DOC_WRITE > SKIP : {
  < ENDDOCWRITE : ")"(" ")*";" > : IN_SCRIPT
| < DOCWRITEMISC : ~[] > 
}
< IN_SC_CMT > SKIP : {
  < ENDSCCMT : "*/" > : IN_SCRIPT
| < SCCMTMISC : ~[] > 
}

< IN_JSSQ > SKIP : {
  < ENDJSSQ : "'" > : IN_SCRIPT
| < JSSQJNK : <HTTPJNKSQ> >
| < JSSQLNK : <HTTPLNKSQ> >
| < JSSQHTTP : <HTTP> >
| < JSSQPORT : <PORT> >
| < JSSQMISC : ~[] > 
}
< IN_JSSQ > TOKEN : {
  < JSDOMSQ : <HTTPDOM> > {
    matchedToken.image = cleanHTML(matchedToken.image);
  }
| < JSEMAILSQ : <EMAIL> >
| < JSPHONESQ : (<PHONE34> | <PHONE32> | <PHONE58>) > {
    
    matchedToken.image = cleanPhone(matchedToken.image);
    
  }
| < JSWORDSQ : <WORD> > {
    matchedToken.image = cleanWord(matchedToken.image);  
  }
}

< IN_JSDQ > SKIP : {
  < ENDJSDQ : "\"" > : IN_SCRIPT
| < JSDQJNK : <HTTPJNKDQ> >
| < JSDQLNK : <HTTPLNKDQ> >
| < JSDQHTTP : <HTTP> >
| < JSDQPORT : <PORT> >
| < JSDQMISC : ~[] > 
}
< IN_JSDQ > TOKEN : {
  < JSDOMDQ : <HTTPDOM> > {
    matchedToken.image = cleanHTML(matchedToken.image);
  }
| < JSEMAILDQ : <EMAIL> >
| < JSPHONEDQ : (<PHONE34> | <PHONE32> | <PHONE58>) > {
    
    matchedToken.image = cleanPhone(matchedToken.image);
    
  }
| < JSWORDDQ : <WORD> > {
    matchedToken.image = cleanWord(matchedToken.image);  
  }
}

/* ============================================================================================
 
   Skip the contents of HTML attributes that may contain unhelpful information, such 
   as style definitions.
   
   These unintentionally create a small amount of garbage, especially the 
   one meant to find HTML links.
 
 ============================================================================================ */

/*
 * "content"
 * "title"
 */

SKIP : {
  < CMTTAG : "<" (" ")*"!"(" ")* > : IN_CMT_TAG
| < OPENTAG : "<" (" ")*( (["a"-"z","A"-"Z","0"-"9","-"])+ )(" ")* > : IN_OPEN_TAG
| < CLOSETAG : "<" (" ")* ( "/"(" ")*(["a"-"z","A"-"Z","0"-"9","-"])+ 
               | (["a"-"z","A"-"Z","0"-"9","-"])+ (" ")*"/" ) (" ")* >
}
< IN_CMT_TAG > SKIP : {
  < ENDCMTTAG : "-"(" ")*">" > : DEFAULT
| < CMTMISC : ~[] >
}
< IN_OPEN_TAG > SKIP : {
  < ENDOPTAG : (">") > : DEFAULT
| < SQATTR : ("alt"|"href") (" ")*"="(" ")* "'" > : IN_SQ
| < DQATTR : ("alt"|"href") (" ")*"="(" ")* "\"" > : IN_DQ
| < OPENMISC : ~[] >
}

// The alt tag may contain useful descriptive information.

<IN_SQ> SKIP : {
  < ENDSQ : ("'") > : IN_OPEN_TAG
| < SQJNK : <HTTPJNKSQ> >
| < SQLNK : <HTTPLNKSQ> >
| < SQHTTP : <HTTP> >
| < SQPORT : <PORT> >
| < SQMISC: ~[] >
}
<IN_SQ> TOKEN : {
  < SQDOM : <HTTPDOM> > {
    matchedToken.image = cleanHTML(matchedToken.image);
  }
| < SQEMAIL : <EMAIL> >
| < SQWORD : (<WORD>|<CONT>) > {
    matchedToken.image = cleanWord(matchedToken.image);  
  }
}

<IN_DQ> SKIP : {
  < ENDDQ : ("\"") > : IN_OPEN_TAG
| < DQJNK : <HTTPJNKDQ> >
| < DQLNK : <HTTPLNKDQ> >
| < DQHTTP : <HTTP> >
| < DQPORT : <PORT> >
| < DQMISC : ~[] >
}
<IN_DQ> TOKEN : {
  < DQDOM : <HTTPDOM> > {
    matchedToken.image = cleanHTML(matchedToken.image);
  }
| < DQEMAIL : <EMAIL> >
| < DQWORD : (<WORD>|<CONT>) > {
    matchedToken.image = cleanWord(matchedToken.image);  
  }
}

/* ============================================================================================
 
   Skip parts of the url that may contribute more garbage than relevant information.

 ============================================================================================ */

SKIP : {
  < HTTPJNKSQ : ["&","?",";"] ( (["a"-"z","A"-"Z","0"-"9"]|<HTTPSYM>|"\""){1,2} )+ ( <HTTPDOM> )?  >
| < HTTPJNKDQ : ["&","?",";"] ( (["a"-"z","A"-"Z","0"-"9"]|<HTTPSYM>|"'"){1,2} )+ ( <HTTPDOM> )?  >
| < HTTPLNKSQ : "/" ( (["a"-"z","A"-"Z","0"-"9"]|<LINKSYM>|"\""){1,2} )+ ( <HTTPDOM> | "."("html"|"php"|"jsp"|"png"|"jpeg"|"jpg"|"css"|"xml") )? >
| < HTTPLNKDQ : "/" ( (["a"-"z","A"-"Z","0"-"9"]|<LINKSYM>|"'"){1,2} )+ ( <HTTPDOM> | "."("html"|"php"|"jsp"|"png"|"jpeg"|"jpg"|"css"|"xml") )? >
| < HTTP : (["a"-"z"])+"://" >
| < PORT : ":"(["0"-"9"]){4,8} >
}

/*
  Only retain HTML domains, parts of the url, email addresses that seem useful.
*/

TOKEN : {	
  < HTTPDOM : ( (["a"-"z","A"-"Z","0"-"9"]){1,2} ( (["a"-"z","A"-"Z","0"-"9","-"]){1,2} )+(".") )+ ( (["a"-"z","A"-"Z"]){1,2} )+ > {
    
    matchedToken.image = cleanHTML(matchedToken.image);
      
  }
| < EMAIL : ( (["a"-"z","A"-"Z","0"-"9"]|<EMAILSYM>){1,2} )+ ( (["a"-"z","A"-"Z","0"-"9","="]|<EMAILSYM>){1,2} )?
            "@" ( ( (["a"-"z","A"-"Z","0"-"9","-"]){1,2} )+(".") )+ ( (["a"-"z","A"-"Z","-"]){1,2} )+ > {
    /*tmp = image.toString().split("\\.");
    matchedToken.image = tmp[tmp.length-1];*/
  }
}

/* ============================================================================================
 
   DEFINITIONS OF CONSTRUCTIONS LIKE TIME, DATES, PRICES, AND PHONE NUMBERS
   | ("p"|"c")
 
 ============================================================================================ */

SKIP : {
  < HHMM : (["0"-"9"]){2}":"(["0"-"9"]){2} (["A","M"]["p","m"])? >
| < HHMMSS : (["0"-"9"]){2}":"(["0"-"9"]){2}":"(["0"-"9"]){2} (["A","M"]["p","m"])? >
| < YMD : (["0"-"9"]){2,4}["-","/"," "] ( (["0"-"9"]){2} | (["a"-"z","A"-"Z"]){3,10}(",")? ) ["-","/"," "] (["0"-"9"]){2} >
| < DMY : (["0"-"9"]){2}["-","/"," "] ( (["0"-"9"]){2} | (["a"-"z","A"-"Z"]){3,10}(",")? ) ["-","/"," "] (["0"-"9"]){2,4} >
| < MDY : ( (["0"-"9"]){2} | (["a"-"z","A"-"Z"]){3,10}(",")? ) ["-","/"," "] (["0"-"9"]){2}["-","/"," "] (["0"-"9"]){2,4} >
}

TOKEN : {
  < PRICE : (["$","€","¥","£","元","₩","₺","₽","₹","R"]|("&83"(["0"-"9"]){2}";")|("Fr"|"kr"))(" ")* 
           ( (["0"-"9"]){1,3}(",")? )+ ( [".",","](["0"-"9"])+ )? > // Need to add unicode & html symb?
| < PRICE2 : ( (["0"-"9"]){1,3}(",")? )+ ( [".",","](["0"-"9"])+ )?(" ")* 
            (  ("dollar"|"euro"|"yen"|"pound"|"franc"|"krona"|"peso"|"krone"|"won"|"lira"|"ruble"|"rupee"|"read"|"rand"|"bitcoin")("s")? | 
               ("USD"|"EUR"|"JPY"|"GBP"|"AUD"|"CAD"|"CHF"|"CNY"|"SEK"|"NZD"|"MXN"|"SGD"|"HKD"|"NOK"|"KRW"|"TRY"|"RUB"|"INR"|"BRL"|"ZAR") 
            ) >
}

/* --------------------------------------------------------------------------------------------
 
   Uses a pattern based approach to identify phone numbers. The most popular numbers 
   internationally had groupings of 3-3-3, 3-3-4, 3-2-2, 2-2-2, or 5-8, which were 
   preceded by specific codes.
 
 -------------------------------------------------------------------------------------------- */

SKIP : {
  < PHONEFI : ("+"|"&#43;") < PSEP > > 
| < PHONESE : ("(")?(["0"-"9"]){1,4}(")")? < PSEP > >
}

TOKEN : {
  < PHONE34 : ( ( ( <PHONEFI> )? <PHONESE> )? < PHONESE > )? (["0"-"9"]){3,4}< PSEP > (["0"-"9"]){3,4} > { 
      
    matchedToken.image = cleanPhone(matchedToken.image);
    
  }
| < PHONE32 : ( ( ( <PHONEFI> )? <PHONESE> )? < PHONESE > )? (["0"-"9"]){2,3}< PSEP > (["0"-"9"]){2}< PSEP > (["0"-"9"]){2} > { 
    
    matchedToken.image = cleanPhone(matchedToken.image);
    
  }
| < PHONE58 : ( < PHONEFI > (["0"-"9"]){1,2}< PSEP > )? ("(")?(["0"-"9"]){2,5}(")")?< PSEP > (["0"-"9"]){5,8} > { 
    
    matchedToken.image = cleanPhone(matchedToken.image);
    
  }
}

    
    
    

/* ============================================================================================
 
   REGEX USED TO COLLECT WORDS.
 
 ============================================================================================ */

TOKEN : {
  < CROWDED : ">" (<WORD>|<CONT>) > {
    
    matchedToken.image = image.substring(image.indexOf(">")+1,image.length());
    
    matchedToken.image = cleanWord(matchedToken.image);
    
  }
| < CROWDED2 : (<WORD>|<CONT>) < CLOSETAG > > {
    
    matchedToken.image = image.substring(0,image.indexOf("<"));
    
    matchedToken.image = cleanWord(matchedToken.image);
    
  }
}

/* --------------------------------------------------------------------------------------------
 
   The following identifies basic words / numbers.
 
 -------------------------------------------------------------------------------------------- */

TOKEN : {
  < BREV : ( < ALPHA > ("&#46;"|["0"-"9","."]) )+ < ALPHA > ("&#46;"|["0"-"9","."]) > {
      
    matchedToken.image = cleanWord(matchedToken.image);
      
  }
| < CONT : ( < ALPHA > )+ ( < ENGSYMB >| < CSEP > | "-" ) ( < ALPHA > )+ > {
  
    matchedToken.image = cleanWord(matchedToken.image);
    
  }
| < WORD : < ALPHA >(< ALPHA >)+ >
}

SKIP : {
  < NUMBER : (["0"-"9"])+>
| < MISC: ~[] >
}
